/*****************************************************************************
* bsp.c for Lab2A of ECE 153a at UCSB
* Date of the Last Update:  October 27,2019
*****************************************************************************/

/**/
#include "qpn_port.h"
#include "bsp.h"
#include "lab2a.h"
#include "xintc.h"
#include "xil_exception.h"
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include "xparameters.h"
#include "xil_printf.h"
#include "xintc.h"
#include "xtmrctr.h"
#include "xgpio.h"
#include "encoder.h"
#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xintc.h"
#include "xtmrctr.h"
#include "xtmrctr_l.h"
#include "xil_printf.h"
#include "xgpio.h"
#include "xspi.h"
#include "xspi_l.h"
#include "lcd.h"

/********* Bit mapping: JA[0]=A, JA[1]=B, JA[2]=Push *********/
#define ENC_A(v)                   (((v)>>0) & 1u)
#define ENC_B(v)                   (((v)>>1) & 1u)
#define ENC_P(v)                   (((v)>>2) & 1u)

#define BTN_GPIO_DEVICE_ID      XPAR_GPIO_2_DEVICE_ID
#define BTN_GPIO_CHANNEL        1
#define BTN_GPIO_IRQ_ID         XPAR_INTC_0_GPIO_2_VEC_ID

#define ENC_GPIO_DEVICE_ID      XPAR_GPIO_0_DEVICE_ID
#define ENC_GPIO_CHANNEL        1
#define ENC_GPIO_IRQ_ID         XPAR_INTC_0_GPIO_0_VEC_ID
/*** ------------------------------------------------ ***/

static XGpio btnGpio;
static XGpio encGpio;

encoder_t enc;

/******************************************************************************
*
* This is the interrupt handler routine for the GPIO for this example.
*
******************************************************************************/
void ButtonsHandler(void *CallbackRef) {
	    // Latch & clear interrupt
	    u32 status = XGpio_InterruptGetStatus(&btnGpio);
	    XGpio_InterruptClear(&btnGpio, status);
	    int btns = XGpio_DiscreteRead(&btnGpio, 1);

	    if (btns & 0x01){ buttonPressed = 1;}
	    else if (btns & 0x02) {buttonPressed = 2;}
	    else if (btns & 0x04) {buttonPressed = 3;}
	    else if (btns & 0x08) {buttonPressed = 4;}
	    QActive_postISR((QActive *)&AO_Lab2A, BUTTON); // Display Text
}

void EncoderHandler(void *CallbackRef)
{
    (void)CallbackRef;
    uint32_t v  = XGpio_DiscreteRead(&encGpio, ENC_GPIO_CHANNEL);
    uint8_t ab  = (ENC_A(v) << 1) | ENC_B(v);
    uint8_t p   = ENC_P(v);

    encoder_quad_step(&enc, ab);      // debounce
    encoder_push_update(&enc, p);     // sets push_rise/push_fall flags (raw)

    // clear source (level-sensitive)
    XGpio_InterruptClear(&encGpio, ENC_GPIO_CHANNEL);

    if(enc.push_rise){
    	enc.push_rise = false;
        QActive_postISR((QActive *)&AO_Lab2A, ENCODER_CLICK); // Mute the system
    }
    if (enc.step_right){
    	enc.step_right = false;
    	QActive_postISR((QActive *)&AO_Lab2A, ENCODER_DOWN); // Decrease Volume
    }
    if (enc.step_left){
    	enc.step_left  = false;
    	QActive_postISR((QActive *)&AO_Lab2A, ENCODER_UP); // Increase Volume
    }
}

void TimerCounterHandler(void *CallBackRef, u8 TmrCtrNumber)
{
	custom_tick += 1;
	if(custom_tick == 400){
		QActive_postISR((QActive *)&AO_Lab2A, CUSTOM_TIMEOUT);
	}
}

/*..........................................................................*/
void BSP_init(void) {
    static XIntc   intc;
    static XTmrCtr axiTimer;
    static XGpio   dc;
    static XSpi    spi;

    XSpi_Config *spiConfig;
    u32 status;
    u32 controlReg;

    // Timer init + ISR hookup
    status = XTmrCtr_Initialize(&axiTimer, XPAR_AXI_TIMER_0_DEVICE_ID);
    if (status != XST_SUCCESS) { xil_printf("Initialize timer fail!\n"); return XST_FAILURE; }

    status = XIntc_Initialize(&intc, XPAR_INTC_0_DEVICE_ID);
    if (status != XST_SUCCESS) { xil_printf("Initialize INTC fail!\n"); return XST_FAILURE; }

    status = XIntc_Connect(&intc,
        XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR,
        (XInterruptHandler)XTmrCtr_InterruptHandler, (void *)&axiTimer);
    if (status != XST_SUCCESS) { xil_printf("Connect timer IHR fail!\n"); return XST_FAILURE; }

    // --- Buttons GPIO init (+ interrupt hookup)
    status = XGpio_Initialize(&btnGpio, BTN_GPIO_DEVICE_ID);
    if (status != XST_SUCCESS) { xil_printf("Initialize button GPIO fail!\n"); return XST_FAILURE; }
    XGpio_SetDataDirection(&btnGpio, BTN_GPIO_CHANNEL, 0xFFFFFFFF); // inputs

    status = XIntc_Connect(&intc, BTN_GPIO_IRQ_ID, (XInterruptHandler)ButtonsHandler, (void *)&btnGpio);
    if (status != XST_SUCCESS) { xil_printf("Connect button IHR fail!\n"); return XST_FAILURE; }

    status = XIntc_Start(&intc, XIN_REAL_MODE);
    if (status != XST_SUCCESS) { xil_printf("Start INTC fail!\n"); return XST_FAILURE; }

    // --- Encoder GPIO init (+ interrupt hookup)
    status = XGpio_Initialize(&encGpio, ENC_GPIO_DEVICE_ID);
    if (status != XST_SUCCESS) { xil_printf("Initialize Encoder GPIO fail!\n"); return XST_FAILURE; }
    XGpio_SetDataDirection(&encGpio, ENC_GPIO_CHANNEL, 0xFFFFFFFF); // inputs
    // enable encoder GPIO interrupts
    XGpio_InterruptDisable(&encGpio, ENC_GPIO_CHANNEL);
    XGpio_InterruptClear(&encGpio,  ENC_GPIO_CHANNEL);
    XGpio_InterruptEnable(&encGpio,  ENC_GPIO_CHANNEL);
    XGpio_InterruptGlobalEnable(&encGpio);


    status = XIntc_Connect(&intc, ENC_GPIO_IRQ_ID, (XInterruptHandler)EncoderHandler, (void *)&encGpio);
    if (status != XST_SUCCESS) { xil_printf("Connect Encoder IHR fail!\n"); return XST_FAILURE; }

    status = XIntc_Start(&intc, XIN_REAL_MODE);
    if (status != XST_SUCCESS) { xil_printf("Start INTC fail!\n"); return XST_FAILURE; }


    // Enable timer + button + encoer interrupts in the INTC and globally
    XIntc_Enable(&intc, XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR);
    XIntc_Enable(&intc, BTN_GPIO_IRQ_ID);
    XIntc_Enable(&intc, ENC_GPIO_IRQ_ID);
    microblaze_enable_interrupts();

    // Enable GPIO-level interrupts for the button block (edge or level as synthesized)
    XGpio_InterruptGlobalEnable(&btnGpio);
    XGpio_InterruptEnable(&btnGpio, 0xFFFF);

    // Timer handler + options
    XTmrCtr_SetHandler(&axiTimer, TimerCounterHandler, &axiTimer);
    XTmrCtr_SetOptions(&axiTimer, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);
    XTmrCtr_SetResetValue(&axiTimer, 0, 0xFFFF0000);
    XTmrCtr_Start(&axiTimer, 0);
    xil_printf("Timer start!\n");

    // SPI DC (data/command) GPIO (existing code)
    status = XGpio_Initialize(&dc, XPAR_SPI_DC_DEVICE_ID);
    if (status != XST_SUCCESS) { xil_printf("Initialize GPIO dc fail!\n"); return XST_FAILURE; }
    XGpio_SetDataDirection(&dc, 1, 0x0);

    // SPI init (existing code)
    spiConfig = XSpi_LookupConfig(XPAR_SPI_DEVICE_ID);
    if (spiConfig == NULL)    { xil_printf("Can't find spi device!\n"); return XST_DEVICE_NOT_FOUND; }
    status = XSpi_CfgInitialize(&spi, spiConfig, spiConfig->BaseAddress);
    if (status != XST_SUCCESS){ xil_printf("Initialize spi fail!\n");   return XST_FAILURE; }
    XSpi_Reset(&spi);
    controlReg = XSpi_GetControlReg(&spi);
    XSpi_SetControlReg(&spi,
        (controlReg | XSP_CR_ENABLE_MASK | XSP_CR_MASTER_MODE_MASK) & (~XSP_CR_TRANS_INHIBIT_MASK));
    XSpi_SetSlaveSelectReg(&spi, ~0x01);



}
/*..........................................................................*/
void QF_onStartup(void) {                 /* entered with interrupts locked */
	xil_printf("\n\rQF_onStartup\n"); // Comment out once you are in your complete program
}


void QF_onIdle(void) {        /* entered with interrupts locked */
    QF_INT_UNLOCK();                       /* unlock interrupts */
}

/* Q_onAssert is called only when the program encounters an error*/
/*..........................................................................*/
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    (void)file;                                   /* name of the file that throws the error */
    (void)line;                                   /* line of the code that throws the error */
    QF_INT_LOCK();
    printDebugLog();
    for (;;) {
    }
}


