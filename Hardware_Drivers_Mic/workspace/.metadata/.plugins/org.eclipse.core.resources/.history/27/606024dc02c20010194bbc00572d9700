#include <stdio.h>
#include "xil_cache.h"
#include <mb_interface.h>

#include "xparameters.h"
#include <xil_types.h>
#include <xil_assert.h>
#include <xio.h>
#include "xtmrctr.h"
#include "fft.h"
#include "note.h"
#include "stream_grabber.h"

// ------------ Config for low latency with padding ------------

#define RAW_SAMPLES   512        // capture 512 raw samples per loop (same as lab)
#define AVG_FACTOR    8          // *** CHANGED *** 8-way averaging
#define EFF_SAMPLES   (RAW_SAMPLES / AVG_FACTOR)   // *** CHANGED *** 512/8 = 64

// We PAD 64 -> 256 for FFT
#define NFFT          128        // *** CHANGED *** zero-padded FFT length
#define MFFT          8          // log2(256)

#define CLOCK         100000000.0   // 100 MHz

// ------------ Buffers ------------

static float q_raw[RAW_SAMPLES];    // 512 raw samples
static float q_eff[EFF_SAMPLES];    // 64 averaged samples
static float w_eff[NFFT];           // use NFFT for imaginary; we'll zero beyond 64

unsigned seqf, seql, seq_old = 0;

// ------------ Grabber read ------------

void read_fsl_values(float *q, int n)
{
    int i;
    unsigned int x;
    const float scale = 3.3f / 67108864.0f; // 3.3V and 2^26 bit precision

    stream_grabber_start();
    stream_grabber_wait_enough_samples(RAW_SAMPLES);

    seql = stream_grabber_read_seq_counter();
    seqf = stream_grabber_read_seq_counter_latched();

    for (i = 0; i < n; i++) {
        x    = stream_grabber_read_sample(i);
        q[i] = scale * (float)x;
    }
}

// ------------ main ------------

int main()
{
    float sample_f_raw;   // ~48.8 kHz
    float sample_f_eff;   // after averaging (fs/8 ~ 6.1 kHz)
    float frequency = 0.0f;
    uint32_t Control;

    // Performance monitor vars
    uint32_t loop_ticks, loop_us, max_loop_us = 0;
    uint32_t loop_counter = 0;

    int i;

    Xil_ICacheInvalidate();
    Xil_ICacheEnable();
    Xil_DCacheInvalidate();
    Xil_DCacheEnable();

    XTmrCtr timer;
    XTmrCtr_Initialize(&timer, XPAR_AXI_TIMER_0_DEVICE_ID);
    Control = XTmrCtr_GetOptions(&timer, 0)
              | XTC_CAPTURE_MODE_OPTION
              | XTC_INT_MODE_OPTION;
    XTmrCtr_SetOptions(&timer, 0, Control);

    print("Maa kaa bhosda AAAGGGGG\n\r");

    XTmrCtr_Start(&timer, 0);

    // Raw sampling frequency from mic block
    sample_f_raw = 100000000.0f / 2048.0f;        // ≈ 48.8 kHz
    sample_f_eff = sample_f_raw / (float)AVG_FACTOR; // *** CHANGED *** ≈ 6.1 kHz

    while (1) {

        uint32_t t_start = XTmrCtr_GetValue(&timer, 0);

        // 1) Acquire 512 raw samples
        read_fsl_values(q_raw, RAW_SAMPLES);
        seq_old = seql;

        // 2) DC removal over RAW_SAMPLES
        float mean = 0.0f;
        for (i = 0; i < RAW_SAMPLES; i++) {
            mean += q_raw[i];
        }
        mean /= (float)RAW_SAMPLES;
        for (i = 0; i < RAW_SAMPLES; i++) {
            q_raw[i] -= mean;
        }

        // 3) 8-way averaging: 512 -> 64 effective samples
        for (i = 0; i < EFF_SAMPLES; i++) {
            int base = i * AVG_FACTOR;  // 0,8,16,...
            float acc = 0.0f;
            acc += q_raw[base + 0];
            acc += q_raw[base + 1];
            acc += q_raw[base + 2];
            acc += q_raw[base + 3];
            acc += q_raw[base + 4];
            acc += q_raw[base + 5];
            acc += q_raw[base + 6];
            acc += q_raw[base + 7];
            q_eff[i] = acc;            // no division; amplitude scale doesn't matter
        }

        // 4) Zero-pad 64 -> 256 for FFT
        //    q_eff[0..63] -> q_eff[0..63], rest 0
        for (i = 0; i < NFFT; i++) {
            if (i < EFF_SAMPLES) {
                // real signal in first 64 points
                // reuse q_eff as real input for fft; zero imag in w_eff
                // (we already stored time-domain in q_eff)
                w_eff[i] = 0.0f;
            } else {
                // zero padding
                q_eff[i] = 0.0f;
                w_eff[i] = 0.0f;
            }
        }

        // 5) Run 256-point FFT on (q_eff, w_eff)
        frequency = fft(q_eff, w_eff, NFFT, MFFT, sample_f_eff);

        uint32_t t_end = XTmrCtr_GetValue(&timer, 0);

        if (t_end >= t_start)
            loop_ticks = t_end - t_start;
        else
            loop_ticks = (0xFFFFFFFFu - t_start) + t_end + 1u;

        loop_us = (uint32_t)((loop_ticks * 1000000.0f) / CLOCK);
        if (loop_us > max_loop_us)
            max_loop_us = loop_us;

        loop_counter++;

        // THROTTLED printing so UART doesn't kill latency
        if ((loop_counter & 0x7) == 0) {  // every 32nd loop
            xil_printf("Loop latency: %u us (max: %u us)\r\n",
                       (unsigned)loop_us, (unsigned)max_loop_us);
            xil_printf("frequency: %d Hz\r\n", (int)(frequency + 0.5f));
        }
    }

    return 0;
}
